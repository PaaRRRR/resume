import letter_X_colored from "../images/takeover/letter_X_colored.svg";
import canvasImage_3 from "../images/takeover/canvas/TakeOver_canvas_103.webp";
import canvasImage_4 from "../images/takeover/canvas/TakeOver_canvas_104.webp";
import canvasImage_5 from "../images/takeover/canvas/TakeOver_canvas_105.webp";
import canvasImage_6 from "../images/takeover/canvas/TakeOver_canvas_106.webp";
import canvasImage_7 from "../images/takeover/canvas/TakeOver_canvas_107.webp";
import canvasImage_8 from "../images/takeover/canvas/TakeOver_canvas_108.webp";
import canvasImage_9 from "../images/takeover/canvas/TakeOver_canvas_109.webp";
import canvasImage_10 from "../images/takeover/canvas/TakeOver_canvas_110.webp";
import canvasImage_11 from "../images/takeover/canvas/TakeOver_canvas_111.webp";
import canvasImage_12 from "../images/takeover/canvas/TakeOver_canvas_112.webp";
import canvasImage_13 from "../images/takeover/canvas/TakeOver_canvas_113.webp";
import canvasImage_14 from "../images/takeover/canvas/TakeOver_canvas_114.webp";
import canvasImage_15 from "../images/takeover/canvas/TakeOver_canvas_115.webp";
import canvasImage_16 from "../images/takeover/canvas/TakeOver_canvas_116.webp";
import canvasImage_17 from "../images/takeover/canvas/TakeOver_canvas_117.webp";
import canvasImage_18 from "../images/takeover/canvas/TakeOver_canvas_118.webp";
import canvasImage_19 from "../images/takeover/canvas/TakeOver_canvas_119.webp";
import canvasImage_20 from "../images/takeover/canvas/TakeOver_canvas_120.webp";
import canvasImage_21 from "../images/takeover/canvas/TakeOver_canvas_121.webp";
import canvasImage_22 from "../images/takeover/canvas/TakeOver_canvas_122.webp";
import canvasImage_23 from "../images/takeover/canvas/TakeOver_canvas_123.webp";
import canvasImage_24 from "../images/takeover/canvas/TakeOver_canvas_124.webp";
import canvasImage_25 from "../images/takeover/canvas/TakeOver_canvas_125.webp";
import canvasImage_26 from "../images/takeover/canvas/TakeOver_canvas_126.webp";
import canvasImage_27 from "../images/takeover/canvas/TakeOver_canvas_127.webp";
import canvasImage_28 from "../images/takeover/canvas/TakeOver_canvas_128.webp";
import canvasImage_29 from "../images/takeover/canvas/TakeOver_canvas_129.webp";
import canvasImage_30 from "../images/takeover/canvas/TakeOver_canvas_130.webp";
import canvasImage_31 from "../images/takeover/canvas/TakeOver_canvas_131.webp";
import canvasImage_32 from "../images/takeover/canvas/TakeOver_canvas_132.webp";
import canvasImage_33 from "../images/takeover/canvas/TakeOver_canvas_133.webp";
import canvasImage_34 from "../images/takeover/canvas/TakeOver_canvas_134.webp";
import canvasImage_35 from "../images/takeover/canvas/TakeOver_canvas_135.webp";
import canvasImage_36 from "../images/takeover/canvas/TakeOver_canvas_136.webp";
import canvasImage_37 from "../images/takeover/canvas/TakeOver_canvas_137.webp";
import canvasImage_38 from "../images/takeover/canvas/TakeOver_canvas_138.webp";
import canvasImage_39 from "../images/takeover/canvas/TakeOver_canvas_139.webp";
import canvasImage_40 from "../images/takeover/canvas/TakeOver_canvas_140.webp";
import canvasImage_41 from "../images/takeover/canvas/TakeOver_canvas_141.webp";
import canvasImage_42 from "../images/takeover/canvas/TakeOver_canvas_142.webp";
import canvasImage_43 from "../images/takeover/canvas/TakeOver_canvas_143.webp";
import canvasImage_44 from "../images/takeover/canvas/TakeOver_canvas_144.webp";
import canvasImage_45 from "../images/takeover/canvas/TakeOver_canvas_145.webp";
import canvasImage_46 from "../images/takeover/canvas/TakeOver_canvas_146.webp";
import canvasImage_47 from "../images/takeover/canvas/TakeOver_canvas_147.webp";
import canvasImage_48 from "../images/takeover/canvas/TakeOver_canvas_148.webp";
import canvasImage_49 from "../images/takeover/canvas/TakeOver_canvas_149.webp";
import canvasImage_50 from "../images/takeover/canvas/TakeOver_canvas_150.webp";
import canvasImage_51 from "../images/takeover/canvas/TakeOver_canvas_151.webp";
import canvasImage_52 from "../images/takeover/canvas/TakeOver_canvas_152.webp";
import canvasImage_53 from "../images/takeover/canvas/TakeOver_canvas_153.webp";
import canvasImage_54 from "../images/takeover/canvas/TakeOver_canvas_154.webp";
import canvasImage_55 from "../images/takeover/canvas/TakeOver_canvas_155.webp";
import canvasImage_56 from "../images/takeover/canvas/TakeOver_canvas_156.webp";
import canvasImage_57 from "../images/takeover/canvas/TakeOver_canvas_157.webp";
import canvasImage_58 from "../images/takeover/canvas/TakeOver_canvas_158.webp";
import canvasImage_59 from "../images/takeover/canvas/TakeOver_canvas_159.webp";
import canvasImage_60 from "../images/takeover/canvas/TakeOver_canvas_160.webp";
import canvasImage_61 from "../images/takeover/canvas/TakeOver_canvas_161.webp";
import canvasImage_62 from "../images/takeover/canvas/TakeOver_canvas_162.webp";
import canvasImage_63 from "../images/takeover/canvas/TakeOver_canvas_163.webp";
import canvasImage_64 from "../images/takeover/canvas/TakeOver_canvas_164.webp";
import canvasImage_65 from "../images/takeover/canvas/TakeOver_canvas_165.webp";
import canvasImage_66 from "../images/takeover/canvas/TakeOver_canvas_166.webp";
import canvasImage_67 from "../images/takeover/canvas/TakeOver_canvas_167.webp";
import canvasImage_68 from "../images/takeover/canvas/TakeOver_canvas_168.webp";
import canvasImage_69 from "../images/takeover/canvas/TakeOver_canvas_169.webp";
import canvasImage_70 from "../images/takeover/canvas/TakeOver_canvas_170.webp";
import canvasImage_71 from "../images/takeover/canvas/TakeOver_canvas_171.webp";
import canvasImage_72 from "../images/takeover/canvas/TakeOver_canvas_172.webp";
import canvasImage_73 from "../images/takeover/canvas/TakeOver_canvas_173.webp";
import canvasImage_74 from "../images/takeover/canvas/TakeOver_canvas_174.webp";
import canvasImage_75 from "../images/takeover/canvas/TakeOver_canvas_175.webp";
import canvasImage_76 from "../images/takeover/canvas/TakeOver_canvas_176.webp";
import canvasImage_77 from "../images/takeover/canvas/TakeOver_canvas_177.webp";
import canvasImage_78 from "../images/takeover/canvas/TakeOver_canvas_178.webp";
import canvasImage_79 from "../images/takeover/canvas/TakeOver_canvas_179.webp";
import canvasImage_80 from "../images/takeover/canvas/TakeOver_canvas_180.webp";
import canvasImage_81 from "../images/takeover/canvas/TakeOver_canvas_181.webp";
import canvasImage_82 from "../images/takeover/canvas/TakeOver_canvas_182.webp";
import canvasImage_83 from "../images/takeover/canvas/TakeOver_canvas_183.webp";
import canvasImage_84 from "../images/takeover/canvas/TakeOver_canvas_184.webp";
import canvasImage_85 from "../images/takeover/canvas/TakeOver_canvas_185.webp";
import canvasImage_86 from "../images/takeover/canvas/TakeOver_canvas_186.webp";
import canvasImage_87 from "../images/takeover/canvas/TakeOver_canvas_187.webp";
import canvasImage_88 from "../images/takeover/canvas/TakeOver_canvas_188.webp";

const importedImgs = [
  canvasImage_3,
  canvasImage_4,
  canvasImage_5,
  canvasImage_6,
  canvasImage_7,
  canvasImage_8,
  canvasImage_9,
  canvasImage_10,
  canvasImage_11,
  canvasImage_12,
  canvasImage_13,
  canvasImage_14,
  canvasImage_15,
  canvasImage_16,
  canvasImage_17,
  canvasImage_18,
  canvasImage_19,
  canvasImage_20,
  canvasImage_21,
  canvasImage_22,
  canvasImage_23,
  canvasImage_24,
  canvasImage_25,
  canvasImage_26,
  canvasImage_27,
  canvasImage_28,
  canvasImage_29,
  canvasImage_30,
  canvasImage_31,
  canvasImage_32,
  canvasImage_33,
  canvasImage_34,
  canvasImage_35,
  canvasImage_36,
  canvasImage_37,
  canvasImage_38,
  canvasImage_39,
  canvasImage_40,
  canvasImage_41,
  canvasImage_42,
  canvasImage_43,
  canvasImage_44,
  canvasImage_45,
  canvasImage_46,
  canvasImage_47,
  canvasImage_48,
  canvasImage_49,
  canvasImage_50,
  canvasImage_51,
  canvasImage_52,
  canvasImage_53,
  canvasImage_54,
  canvasImage_55,
  canvasImage_56,
  canvasImage_57,
  canvasImage_58,
  canvasImage_59,
  canvasImage_60,
  canvasImage_61,
  canvasImage_62,
  canvasImage_63,
  canvasImage_64,
  canvasImage_65,
  canvasImage_66,
  canvasImage_67,
  canvasImage_68,
  canvasImage_69,
  canvasImage_70,
  canvasImage_71,
  canvasImage_72,
  canvasImage_73,
  canvasImage_74,
  canvasImage_75,
  canvasImage_76,
  canvasImage_77,
  canvasImage_78,
  canvasImage_79,
  canvasImage_80,
  canvasImage_81,
  canvasImage_82,
  canvasImage_83,
  canvasImage_84,
  canvasImage_85,
  canvasImage_86,
  canvasImage_87,
  canvasImage_88,
];
class BannerHighlight extends HTMLElement {
  constructor() {
    super();

    this.init();
  }

  init() {
    this.stickyElement = this.querySelector("[data-banner-sticky]");
    this.contrastElement = this.querySelector("[data-banner-contrast]");
    this.is_nav_shown = false;
    this.navElement = document.querySelector("nav");
    this.canvas = this.querySelector(".canvas-animation-01");
    this.canvas2 = this.querySelector(".canvas-animation-02");
    this.canvas3 = this.querySelector(".canvas-animation-03");
    this.canvas4 = this.querySelector(".canvas-animation-04");
    this.canvas5 = this.querySelector(".canvas-animation-05");
    this.ctx = this.canvas.getContext("2d");
    this.ctx2 = this.canvas2.getContext("2d");
    this.ctx3 = this.canvas3.getContext("2d");
    this.ctx4 = this.canvas4.getContext("2d");
    this.ctx5 = this.canvas5.getContext("2d");

    this.sizes = {
      width: 0,
      height: 0,
    };

    this.resizeHandler();

    this.getVariables();

    this.getStartingPoint();
    this.setAnimationValue();
    this.loadAsset();

    window.addEventListener("scroll", this.scrollHandler.bind(this));
    if (this.sizes.width > 750) {
      window.addEventListener("resize", this.resizeHandler.bind(this));
    }
    window.addEventListener("orientationchange", () => {
      this.orientation = screen.orientation.type;
    });
  }

  resizeHandler() {
    this.sizes.width = document.body.clientWidth;
    this.sizes.height =
      this.sizes.width > 750 ? window.innerHeight : window.outerHeight;

    this.highResolution(this.canvas, this.ctx);
    this.highResolution(this.canvas2, this.ctx2);
    this.highResolution(this.canvas3, this.ctx3);
    this.highResolution(this.canvas4, this.ctx4);
    this.highResolution(this.canvas5, this.ctx5);
  }

  highResolution(canvas, ctx) {
    // Get the DPR and size of the canvas
    const dpr = window.devicePixelRatio;
    const { width, height } = this.sizes;

    // Set the "actual" size of the canvas
    canvas.width = width * dpr;
    canvas.height = height * dpr;

    // Scale the context to ensure correct drawing operations
    ctx.scale(dpr, dpr);

    // Set the "drawn" size of the canvas
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
  }

  getVariables() {
    this.canvasImages = [];
    this.xLetter = {
      width: 538,
      height: 347,
      ratio: 0.645,
      img: "",
    };
    this.canvasFontSizeRatio = 300 / 1680;
    this.canvasFontPxHRatio = 240 / 300;
    this.diamond = [];
    this.diamondScaleRatio = 1.4;
    this.orientation = screen.orientation.type;
    this.paths = [...document.querySelectorAll(".svg-path-animation path")];
    this.animation_status = "bar";

    this.svgPathIntro = document.querySelector(".svg-path-intro");
    this.svgPathAnimationEl = document.querySelector(".svg-path-animation");
  }

  loadAsset() {
    this.loadDiamond();
    let loadCount = 3;
    const onload = () => --loadCount === 0 && this.loadHandler();
    this.loadCanvasImage(onload);
    this.loadFont(onload);
    this.loadXLetter(onload);
  }

  loadHandler() {
    this.svgPathIntro.classList.add("intro");

    setTimeout(() => {
      document.body.style.overflow = "unset";
      // document.querySelector("nav").style.display = "block";

      this.diamondResizeHandler();
    }, 3000);
  }

  diamondResizeHandler() {
    this.ctx4.save();
    this.ctx4.restore();

    const originalSize = Math.max(this.sizes.width, this.sizes.height);
    const scaledSize = originalSize * this.diamondScaleRatio;

    if (this.orientation.includes("portrait")) {
      this.ctx4.translate(this.sizes.width / 2, -this.sizes.height / 2);
    } else {
      this.ctx4.translate(scaledSize / 2, -scaledSize / 2);
    }

    this.ctx4.rotate(Math.PI / 4);
  }

  loadCanvasImage(callback = () => {}) {
    let imgElem;
    let numLoading = 86;
    const onload = () => --numLoading === 0 && callback();
    for (let i = 0; i < numLoading; i += 1) {
      imgElem = new Image();
      imgElem.src = importedImgs[i];
      this.canvasImages.push(imgElem);
      imgElem.onload = onload;
    }
  }

  loadDiamond() {
    let row_num = 8;
    const originalSize = Math.max(this.sizes.width, this.sizes.height);
    const scaledSize = originalSize * this.diamondScaleRatio;
    const targetBoxSize = Math.floor(scaledSize / row_num);

    for (let i = 0; i < row_num * row_num; i += 1) {
      let mok = Math.floor(i / row_num);
      let posX = targetBoxSize * (i % row_num);
      let posY = targetBoxSize * mok;
      this.diamond.push(
        new Shape(posX, posY, targetBoxSize, targetBoxSize, "#ABE9F9")
      );
    }
  }

  loadFont(callback = () => {}) {
    const fontUrl = new URL(
      `../fonts/DharmaGothicC-HeavyItalic.ttf`,
      import.meta.url
    ).href;
    const myFont = new FontFace("DharmaGothicC-HeavyItalic", `url(${fontUrl})`);

    myFont.load().then((font) => {
      document.fonts.add(font);
      callback();
    });
  }

  loadXLetter(callback = () => {}) {
    this.xLetter.img = new Image();
    this.xLetter.img.src = letter_X_colored;
    this.xLetter.img.onload = callback;
  }

  /* sticky element animation part */

  canvasImageAnimation(ctx, percentage) {
    const canvasImages = this.canvasImages;
    let calcedIndex = Math.floor(canvasImages.length * percentage);
    if (!calcedIndex || calcedIndex < 0) {
      calcedIndex = 0;
    } else if (calcedIndex >= canvasImages.length) {
      calcedIndex = canvasImages.length - 1;
    }

    const currentImg = canvasImages[calcedIndex];

    ctx.clearRect(0, 0, this.sizes.width, this.sizes.height);
    ctx.drawImage(currentImg, 0, 0, this.sizes.width, this.sizes.height);
  }

  renderStrokeText(ctx, percentage) {
    const word = "TAKE OVER";

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    let wordIndex = Math.ceil(word.length * percentage);
    const currentText = word.slice(0, wordIndex);
    let fontSize = this.sizes.width * this.canvasFontSizeRatio;
    fontSize = this.orientation.includes("portrait") ? fontSize * 3 : fontSize;

    this.strokeText(ctx, currentText, fontSize, "#FCEB57", true);
  }

  renderFillText(ctx, percentage) {
    const word = "TAKE OVER";

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    let calcedPercentage = Math.ceil(percentage * 10);
    let fontSize = this.sizes.width * this.canvasFontSizeRatio;
    fontSize = this.orientation.includes("portrait") ? fontSize * 3 : fontSize;

    if (calcedPercentage % 2 == 0) {
      this.fillText(
        ctx,
        word,
        Math.floor(fontSize + fontSize * (calcedPercentage / 15))
      );
    } else {
      ctx.clearRect(0, 0, this.sizes.width, this.sizes.height);
    }
  }

  fillText(
    ctx,
    text = "TAKE OVER",
    size = 300,
    color = "#FCEB57",
    reverse = false
  ) {
    ctx.clearRect(0, 0, this.sizes.width, this.sizes.height);
    ctx.font = `${size}px DharmaGothicC-HeavyItalic`;
    ctx.fillStyle = color;

    if (this.orientation.includes("portrait")) {
      let textArray = text.split(" ");
      if (textArray.length > 1) {
        let xPos1 = this.sizes.width / 2;
        let yPos1 =
          this.sizes.height / 2 - (size * this.canvasFontPxHRatio) / 2;
        let xPos2 = this.sizes.width / 2;
        let yPos2 =
          this.sizes.height / 2 + (size * this.canvasFontPxHRatio) / 2;

        if (reverse) {
          ctx.translate(0, 0);
          ctx.rotate(Math.PI);

          xPos1 = 0 - this.sizes.width / 2;
          yPos1 =
            0 - this.sizes.height / 2 - (size * this.canvasFontPxHRatio) / 2;
          xPos2 = 0 - this.sizes.width / 2;
          yPos2 =
            0 - this.sizes.height / 2 + (size * this.canvasFontPxHRatio) / 2;
        }

        xPos1 = Math.floor(xPos1);
        yPos1 = Math.floor(yPos1);
        xPos2 = Math.floor(xPos2);
        yPos2 = Math.floor(yPos2);

        ctx.fillText(textArray[0], xPos1, yPos1);
        ctx.fillText(textArray[1], xPos2, yPos2);
      } else {
        let xPos = this.sizes.width / 2;
        let yPos = this.sizes.height / 2;

        if (reverse) {
          ctx.translate(0, 0);
          ctx.rotate(Math.PI);

          xPos = 0 - this.sizes.width / 2;
          yPos = 0 - this.sizes.height / 2;
        }

        xPos = Math.floor(xPos);
        yPos = Math.floor(yPos);

        ctx.fillText(text, xPos, yPos);
      }
    } else {
      let xPos = this.sizes.width / 2;
      let yPos = this.sizes.height / 2;

      if (reverse) {
        ctx.translate(0, 0);
        ctx.rotate(Math.PI);

        xPos = 0 - this.sizes.width / 2;
        yPos = 0 - this.sizes.height / 2;
      }

      xPos = Math.floor(xPos);
      yPos = Math.floor(yPos);

      ctx.fillText(text, xPos, yPos);
    }
  }

  strokeText(
    ctx,
    text = "TAKE OVER",
    size = 300,
    color = "#FCEB57",
    reverse = false
  ) {
    ctx.clearRect(0, 0, this.sizes.width, this.sizes.height);
    ctx.font = `${size}px DharmaGothicC-HeavyItalic`;
    ctx.strokeStyle = color;

    if (this.orientation.includes("portrait")) {
      let textArray = text.split(" ");
      if (textArray.length > 1) {
        let xPos1 = this.sizes.width / 2;
        let yPos1 =
          this.sizes.height / 2 - (size * this.canvasFontPxHRatio) / 2;
        let xPos2 = this.sizes.width / 2;
        let yPos2 =
          this.sizes.height / 2 + (size * this.canvasFontPxHRatio) / 2;

        if (reverse) {
          ctx.translate(0, 0);
          ctx.rotate(Math.PI);

          xPos1 = 0 - this.sizes.width / 2;
          yPos1 =
            0 - this.sizes.height / 2 - (size * this.canvasFontPxHRatio) / 2;
          xPos2 = 0 - this.sizes.width / 2;
          yPos2 =
            0 - this.sizes.height / 2 + (size * this.canvasFontPxHRatio) / 2;
        }

        xPos1 = Math.floor(xPos1);
        yPos1 = Math.floor(yPos1);
        xPos2 = Math.floor(xPos2);
        yPos2 = Math.floor(yPos2);

        ctx.strokeText(textArray[0], xPos1, yPos1);
        ctx.strokeText(textArray[1], xPos2, yPos2);
      } else {
        let xPos = this.sizes.width / 2;
        let yPos = this.sizes.height / 2;

        if (reverse) {
          ctx.translate(0, 0);
          ctx.rotate(Math.PI);

          xPos = 0 - this.sizes.width / 2;
          yPos = 0 - this.sizes.height / 2;
        }

        xPos = Math.floor(xPos);
        yPos = Math.floor(yPos);

        ctx.strokeText(text, xPos, yPos);
      }
    } else {
      let xPos = this.sizes.width / 2;
      let yPos = this.sizes.height / 2;

      if (reverse) {
        ctx.translate(0, 0);
        ctx.rotate(Math.PI);

        xPos = 0 - this.sizes.width / 2;
        yPos = 0 - this.sizes.height / 2;
      }

      xPos = Math.floor(xPos);
      yPos = Math.floor(yPos);

      ctx.strokeText(text, xPos, yPos);
    }
  }

  renderRect(ctx, percentage) {
    let barWidth = Math.floor(this.sizes.width * percentage);

    let rightBarXPos = this.sizes.width - barWidth;

    let barHeight = Math.floor(this.sizes.height / 2);

    ctx.fillStyle = "#000000";

    ctx.clearRect(0, 0, this.sizes.width, this.sizes.height);

    // left
    ctx.fillRect(0, 0, barWidth, barHeight);

    // right
    ctx.fillRect(
      rightBarXPos,
      barHeight,
      barWidth,
      this.sizes.height - barHeight
    );
  }

  // this needs to be changed to another path not #outline.
  svgPathAnimation(percentage) {
    for (let i = 0; i < this.paths.length; i += 1) {
      let path = this.paths[i];

      let value = 50 * percentage;
      let reverseValue = 50 - value;
      let strokeDasharray = `${reverseValue}% ${value}%`;

      path.style.strokeDasharray = strokeDasharray;
    }
  }

  renderDiamond(ctx, percentage) {
    const originalSize = Math.max(this.sizes.width, this.sizes.height);
    const scaledSize = originalSize * this.diamondScaleRatio;

    ctx.clearRect(0, 0, scaledSize, scaledSize);

    this.diamond.forEach((cur) => {
      ctx.fillStyle = cur.fill;

      const targetWidth = cur.w * percentage;
      const difference = cur.w - targetWidth;
      const targetX = cur.x + difference / 2;
      const targetY = cur.y + difference / 2;

      ctx.fillRect(targetX, targetY, targetWidth, targetWidth);
    });
  }

  xLetterAnimation(ctx, img, percentage) {
    ctx.clearRect(0, 0, this.sizes.width, this.sizes.height);
    let imgWidth = this.sizes.width * percentage * 10; // 539 : 50 = x : this.sizes.width
    let imgHeight = imgWidth * this.xLetter.ratio;

    if (this.orientation.includes("portrait")) {
      imgHeight = this.sizes.height * percentage * 7; // 348 : 50 = y : this.sizes.height
      imgWidth = imgHeight / this.xLetter.ratio;
    }

    imgWidth = Math.floor(imgWidth);
    imgHeight = Math.floor(imgHeight);

    const startXPoint = Math.floor(this.sizes.width / 2 - imgWidth / 2);
    const startYPoint = Math.floor(this.sizes.height / 2 - imgHeight / 2);

    // ctx.beginPath();
    ctx.fillStyle = "#ABE9F9";
    ctx.rect(0, 0, this.sizes.width, startYPoint);
    ctx.rect(0, startYPoint - 1, startXPoint + 1, imgHeight + 1);
    ctx.rect(
      this.sizes.width - startXPoint - 1,
      startYPoint - 1,
      startXPoint + 1,
      imgHeight + 1
    );
    ctx.rect(
      0,
      this.sizes.height - startYPoint,
      this.sizes.width,
      this.sizes.height
    );
    ctx.fill();
    ctx.clearRect(
      startXPoint + 8,
      startYPoint + 8,
      imgWidth - 8,
      imgHeight - 8
    );

    ctx.drawImage(img, startXPoint, startYPoint, imgWidth, imgHeight);
  }

  /* end of animation part */

  getStartingPoint() {
    let { top, height } = this.getBoundingClientRect();
    this.startingYOffset = top + scrollY;

    this.screenHeight = innerHeight;
    this.height = height;
  }

  setAnimationValue() {
    let rectAnimation = [0, 1, { start: 0, end: 0 }],
      strokeTextAnimation = [0, 1, { start: 0, end: 0 }],
      fillTextAnimation = [0, 1, { start: 0, end: 0 }],
      diamondAnimation = [0, 1, { start: 0, end: 0 }],
      xLetterAnimation = [0, 1, { start: 0, end: 0 }],
      svgPathAnimation = [0, 1, { start: 0, end: 0 }],
      canvasImageAnimation = [0, 1, { start: 0, end: 0 }],
      canvasOpacityOut = [1, 0, { start: 0, end: 0 }],
      opacityOut = [1, 0, { start: 0, end: 0 }],
      contrastIn = [255, 0, { start: 0, end: 0 }];

    let { top, height } = this.contrastElement.getBoundingClientRect();
    let contrastElementStartingYOffset = top + scrollY;

    // contrastElement찾고,
    // 거기서 +150px까지 opacity 0으로
    // 거기서 +150px부터 startAt
    // 페이지 절반왔을 때 endsAt

    let oneStepAmount = 100;
    let halfHeight = this.screenHeight / 2;
    halfHeight = Math.max(500, halfHeight);
    let contrastStartAt =
      contrastElementStartingYOffset - this.startingYOffset - this.screenHeight; // normalize

    let contrastEndAt = contrastStartAt + halfHeight;
    let opacityOutEndAt = contrastStartAt + 4.5 * oneStepAmount;

    contrastIn[2].start = (contrastStartAt + 1.5 * oneStepAmount) / this.height;
    contrastIn[2].end = contrastEndAt / this.height;
    opacityOut[2].end = opacityOutEndAt / this.height;

    const stickyElementLong = contrastIn[2].start;
    // 10, 5, 5, 10, 10, 5, 10, 5
    // rect, strokeText,fillText, diamond, xLetter, svgPath, canvasImage, canvasOut
    const stickyElementStep = stickyElementLong / 60;
    rectAnimation[2].start = 0;
    rectAnimation[2].end = rectAnimation[2].start + 10 * stickyElementStep;
    strokeTextAnimation[2].start = rectAnimation[2].end;
    strokeTextAnimation[2].end =
      strokeTextAnimation[2].start + 5 * stickyElementStep;
    fillTextAnimation[2].start = strokeTextAnimation[2].end;
    fillTextAnimation[2].end =
      fillTextAnimation[2].start + 5 * stickyElementStep;
    diamondAnimation[2].start = fillTextAnimation[2].end;
    diamondAnimation[2].end =
      diamondAnimation[2].start + 10 * stickyElementStep;
    xLetterAnimation[2].start = diamondAnimation[2].end;
    xLetterAnimation[2].end =
      xLetterAnimation[2].start + 10 * stickyElementStep;
    svgPathAnimation[2].start = xLetterAnimation[2].end;
    svgPathAnimation[2].end = svgPathAnimation[2].start + 5 * stickyElementStep;
    canvasImageAnimation[2].start = svgPathAnimation[2].end;
    canvasImageAnimation[2].end =
      canvasImageAnimation[2].start + 10 * stickyElementStep;
    canvasOpacityOut[2].start = canvasImageAnimation[2].end;
    canvasOpacityOut[2].end =
      canvasOpacityOut[2].start + 2.5 * stickyElementStep;
    opacityOut[2].start = canvasOpacityOut[2].end;

    this.animateValue = {
      rectAnimation,
      strokeTextAnimation,
      fillTextAnimation,
      diamondAnimation,
      xLetterAnimation,
      svgPathAnimation,
      canvasImageAnimation,
      canvasOpacityOut,

      opacityOut,
      contrastIn,
    };
  }

  calcAnimatedValue(values, currentScrollY, height) {
    let rv;

    const partScrollStart = values[2].start * height;
    const partScrollEnd = values[2].end * height;
    const partScrollHeight = partScrollEnd - partScrollStart;

    if (currentScrollY >= partScrollStart && currentScrollY <= partScrollEnd) {
      rv =
        ((currentScrollY - partScrollStart) / partScrollHeight) *
          (values[1] - values[0]) +
        values[0];
    } else if (currentScrollY < partScrollStart) {
      rv = values[0];
    } else if (currentScrollY > partScrollEnd) {
      rv = values[1];
    }

    return rv;
  }

  scrollHandler(e) {
    // animation handler
    if (
      scrollY > this.startingYOffset &&
      scrollY < this.startingYOffset + this.height
    ) {
      this.currentScrollY = Math.abs(this.startingYOffset - scrollY);

      let scrollRatio = this.currentScrollY / this.height;

      let {
        rectAnimation,
        strokeTextAnimation,
        fillTextAnimation,
        diamondAnimation,
        xLetterAnimation,
        svgPathAnimation,
        canvasImageAnimation,
        canvasOpacityOut,
        opacityOut,
        contrastIn,
      } = this.animateValue;

      // sticky element animation
      if (
        scrollRatio >= rectAnimation[2].start &&
        scrollRatio < rectAnimation[2].end
      ) {
        if (this.animation_status != "rect") {
          this.animation_status = "rect";

          this.canvas.style.display = "block";
          this.canvas2.style.display = "none";
          this.canvas3.style.display = "none";
          this.canvas4.style.display = "none";
          this.canvas5.style.display = "none";
        }

        const value = this.calcAnimatedValue(
          rectAnimation,
          this.currentScrollY,
          this.height
        );

        this.renderRect(this.ctx, value);
      } else if (
        scrollRatio >= strokeTextAnimation[2].start &&
        scrollRatio < strokeTextAnimation[2].end
      ) {
        if (this.animation_status != "strokeText") {
          this.animation_status = "strokeText";

          this.canvas.style.display = "none";
          this.canvas2.style.display = "block";
          this.canvas3.style.display = "none";
          this.canvas4.style.display = "none";
          this.canvas5.style.display = "none";
        }

        const value = this.calcAnimatedValue(
          strokeTextAnimation,
          this.currentScrollY,
          this.height
        );

        this.renderStrokeText(this.ctx2, value);
      } else if (
        scrollRatio >= fillTextAnimation[2].start &&
        scrollRatio < fillTextAnimation[2].end
      ) {
        if (this.animation_status != "fillText") {
          this.animation_status = "fillText";

          this.canvas.style.display = "none";
          this.canvas2.style.display = "block";
          this.canvas3.style.display = "block";
          this.canvas4.style.display = "none";
          this.canvas5.style.display = "none";
        }

        const value = this.calcAnimatedValue(
          fillTextAnimation,
          this.currentScrollY,
          this.height
        );

        this.renderFillText(this.ctx3, value);
      } else if (
        scrollRatio >= diamondAnimation[2].start &&
        scrollRatio < diamondAnimation[2].end
      ) {
        if (this.animation_status != "diamond") {
          this.animation_status = "diamond";

          this.canvas.style.display = "none";
          this.canvas2.style.display = "block";
          this.canvas3.style.display = "block";
          this.canvas4.style.display = "block";
          this.canvas5.style.display = "none";

          this.svgPathIntro.style.opacity = "1";
          this.svgPathAnimationEl.style.opacity = "0";
        }

        const value = this.calcAnimatedValue(
          diamondAnimation,
          this.currentScrollY,
          this.height
        );

        this.renderDiamond(this.ctx4, value);
      } else if (
        scrollRatio >= xLetterAnimation[2].start &&
        scrollRatio < xLetterAnimation[2].end
      ) {
        if (this.animation_status != "xLetter") {
          this.animation_status = "xLetter";

          this.canvas.style.display = "none";
          this.canvas2.style.display = "none";
          this.canvas3.style.display = "none";
          this.canvas4.style.display = "none";
          this.canvas5.style.display = "block";

          this.svgPathIntro.style.opacity = "0";
          this.svgPathAnimationEl.style.opacity = "1";

          this.svgPathAnimation(0);
        }

        const value = this.calcAnimatedValue(
          xLetterAnimation,
          this.currentScrollY,
          this.height
        );

        this.xLetterAnimation(this.ctx5, this.xLetter.img, value);
      } else if (
        scrollRatio >= svgPathAnimation[2].start &&
        scrollRatio < svgPathAnimation[2].end
      ) {
        if (this.animation_status != "svgPath") {
          this.animation_status = "svgPath";

          this.ctx5.clearRect(0, 0, this.sizes.width, this.sizes.height);
        }

        const value = this.calcAnimatedValue(
          svgPathAnimation,
          this.currentScrollY,
          this.height
        );

        this.svgPathAnimation(value);
      } else if (
        scrollRatio >= canvasImageAnimation[2].start &&
        scrollRatio < canvasImageAnimation[2].end
      ) {
        if (this.animation_status != "canvas") {
          this.animation_status = "canvas";
          this.svgPathAnimation(1);
          this.canvas5.style.opacity = 1;
        }

        const value = this.calcAnimatedValue(
          canvasImageAnimation,
          this.currentScrollY,
          this.height
        );

        this.canvasImageAnimation(this.ctx5, value);
      } else if (
        scrollRatio >= canvasOpacityOut[2].start &&
        scrollRatio < canvasOpacityOut[2].end
      ) {
        if (this.animation_status != "canvasOpacityOut") {
          this.animation_status = "canvasOpacityOut";
        }

        const value = this.calcAnimatedValue(
          canvasOpacityOut,
          this.currentScrollY,
          this.height
        );

        this.canvas5.style.opacity = value;
      } else {
        this.canvas5.style.opacity = 0;
      }

      // start contrast effect,,
      if (scrollRatio < opacityOut[2].start) {
        this.stickyElement.style.opacity = 1;
      } else if (scrollRatio > opacityOut[2].end) {
        this.stickyElement.style.opacity = 0;
      } else {
        this.stickyElement.style.opacity = this.calcAnimatedValue(
          opacityOut,
          this.currentScrollY,
          this.height
        );
      }

      // this is for contrast effect
      if (scrollRatio < contrastIn[2].start) {
        let calcedValue = 255;
        let reversedValue = 255 - calcedValue;

        document.documentElement.style.setProperty(
          "--text-color-value",
          `${calcedValue}, ${calcedValue}, ${calcedValue}`
        );
        document.documentElement.style.setProperty(
          "--background-color-value",
          `${reversedValue}, ${reversedValue}, ${reversedValue}`
        );
      } else if (scrollRatio > contrastIn[2].end) {
        let calcedValue = 0;
        let reversedValue = 255 - calcedValue;

        document.documentElement.style.setProperty(
          "--text-color-value",
          `${calcedValue}, ${calcedValue}, ${calcedValue}`
        );
        document.documentElement.style.setProperty(
          "--background-color-value",
          `${reversedValue}, ${reversedValue}, ${reversedValue}`
        );
      } else {
        let calcedValue = this.calcAnimatedValue(
          contrastIn,
          this.currentScrollY,
          this.height
        );
        let reversedValue = 255 - calcedValue;

        document.documentElement.style.setProperty(
          "--text-color-value",
          `${calcedValue}, ${calcedValue}, ${calcedValue}`
        );
        document.documentElement.style.setProperty(
          "--background-color-value",
          `${reversedValue}, ${reversedValue}, ${reversedValue}`
        );
      }
    } else if (scrollY <= 0 || scrollY < this.startingYOffset) {
      this.stickyElement.style.opacity = 1;
      document.documentElement.style.setProperty(
        "--text-color-value",
        `255, 255, 255`
      );
      document.documentElement.style.setProperty(
        "--background-color-value",
        `0, 0, 0`
      );
    } else {
      this.stickyElement.style.opacity = 0;
      document.documentElement.style.setProperty(
        "--text-color-value",
        `0, 0, 0`
      );
      document.documentElement.style.setProperty(
        "--background-color-value",
        `255, 255, 255`
      );
    }

    // show / hide the nav
    let { top } = this.contrastElement.getBoundingClientRect();
    let halfHeight = innerHeight / 2;
    halfHeight = Math.max(500, halfHeight);

    if (scrollY > top + scrollY - halfHeight) {
      if (this.is_nav_shown) {
        return;
      }

      this.is_nav_shown = true;
      this.navElement.style.display = "block";
    } else {
      if (!this.is_nav_shown) {
        return;
      }

      this.is_nav_shown = false;
      this.navElement.style.display = "none";
    }
  }
}

class Shape {
  constructor(x, y, w, h, fill) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.fill = fill;
  }
}

window.customElements.define("banner-highlight", BannerHighlight);
